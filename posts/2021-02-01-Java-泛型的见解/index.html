<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Java 泛型的见解 - 北邙山之光的 Blog</title><meta name="Description" content=""><meta property="og:title" content="Java 泛型的见解" />
<meta property="og:description" content="前言 写 RecyclerView 的 Adapter 时，感觉到了泛型理解不够深刻，也不够熟练，看了几天的泛型文档 https://docs.oracle.com/javase/tutorial/java/generics/index.html 下面的总结均是对于文档的学习和一些代码示例的运行。 为什么要使用泛型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://PTrain666.github.io/posts/2021-02-01-Java-%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%A7%81%E8%A7%A3/" /><meta property="og:image" content="http://PTrain666.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-02-01T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://PTrain666.github.io/logo.png"/>

<meta name="twitter:title" content="Java 泛型的见解"/>
<meta name="twitter:description" content="前言 写 RecyclerView 的 Adapter 时，感觉到了泛型理解不够深刻，也不够熟练，看了几天的泛型文档 https://docs.oracle.com/javase/tutorial/java/generics/index.html 下面的总结均是对于文档的学习和一些代码示例的运行。 为什么要使用泛型"/>
<meta name="application-name" content="北邙山之光的 Blog">
<meta name="apple-mobile-web-app-title" content="北邙山之光的 Blog"><link rel="icon" href="/img/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="canonical" href="http://PTrain666.github.io/posts/2021-02-01-Java-%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%A7%81%E8%A7%A3/" /><link rel="prev" href="http://PTrain666.github.io/posts/2021-01-24-Kotlin-Coroutines-VS-Goroutines/" /><link rel="next" href="http://PTrain666.github.io/posts/2021-02-07-%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%8D%E4%BE%8B/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Java 泛型的见解",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/PTrain666.github.io\/posts\/2021-02-01-Java-%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%A7%81%E8%A7%A3\/"
        },"genre": "posts","keywords": "Java","wordcount":  2754 ,
        "url": "http:\/\/PTrain666.github.io\/posts\/2021-02-01-Java-%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%A7%81%E8%A7%A3\/","datePublished": "2021-02-01T00:00:00+00:00","dateModified": "2021-02-01T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": "北邙山之光"},"author": {
                "@type": "Person",
                "name": "北邙山之光"
            },"description": ""
    }
    </script><script data-ad-client="ca-pub-4814124987641317" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('light' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'light' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="北邙山之光的 Blog"><span class="header-title-pre"><i class='far fa-dizzy'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="/cv/"> 简历 </a><a class="menu-item" href="https://github.com/PTrain666" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="北邙山之光的 Blog"><span class="header-title-pre"><i class='far fa-dizzy'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="/cv/" title="">简历</a><a class="menu-item" href="https://github.com/PTrain666" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Java 泛型的见解</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>北邙山之光</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-02-01">2021-02-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2754 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 6 分钟&nbsp;
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#为什么要使用泛型">为什么要使用泛型</a>
      <ul>
        <li><a href="#代码复用">代码复用</a></li>
        <li><a href="#减少强转">减少强转</a></li>
      </ul>
    </li>
    <li><a href="#泛型类接口方法的声明">泛型类、接口、方法的声明</a></li>
    <li><a href="#原始类型raw-type">原始类型(Raw Type)</a></li>
    <li><a href="#泛型的继承和子类型">泛型的继承和子类型</a></li>
    <li><a href="#类型推断type-inference">类型推断(Type Inference)</a></li>
    <li><a href="#通配符wildcards">通配符(Wildcards)</a>
      <ul>
        <li><a href="#上界通配符upper-bounded-wildcards">上界通配符(Upper Bounded Wildcards)</a></li>
        <li><a href="#下界通配符lower-bounded-wildcards">下界通配符(Lower Bounded Wildcards)</a></li>
        <li><a href="#无界通配符unbounded-wildcards">无界通配符(unBounded Wildcards)</a></li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
    <li><a href="#类型擦除和桥方法">类型擦除和桥方法</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="前言">前言</h2>
<p>写 RecyclerView 的 Adapter 时，感觉到了泛型理解不够深刻，也不够熟练，看了几天的泛型文档</p>
<p><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html" target="_blank" rel="noopener noreffer">https://docs.oracle.com/javase/tutorial/java/generics/index.html</a></p>
<p>下面的总结均是对于文档的学习和一些代码示例的运行。</p>
<h2 id="为什么要使用泛型">为什么要使用泛型</h2>
<h3 id="代码复用">代码复用</h3>
<p>通常的代码复用是提取一个公共参数的函数，函数中的参数传的是各种不同的值。泛型也是类似，只不过泛型可以用于定义 class、interface、method 等等，泛型传递的是不同的 type。</p>
<h3 id="减少强转">减少强转</h3>
<p>如果没有泛型，很多时候我们都需要类型强转。但是，使用了泛型以后，因为编译时有 type check，所以自然可以不用写类型强转的代码。</p>
<h2 id="泛型类接口方法的声明">泛型类、接口、方法的声明</h2>
<p>在我们声明泛型的时候经常带着绑定的类型参数，比如 <code>List&lt;E&gt;</code> 等等，这里的 E 就是类型参数，类型参数有一些 <code>约定(conventions)</code>，如下：</p>
<ul>
<li>E - Element (used extensively by the Java Collections Framework)</li>
<li>K - Key</li>
<li>N - Number</li>
<li>T - Type</li>
<li>V - Value</li>
<li>S,U,V etc. - 2nd, 3rd, 4th types</li>
</ul>
<p>但是好像平时写的时候，也很少有人遵守。比如我就用过一个 <code>VH</code> 的类型参数，只是因为继承了一个叫做 ViewHolder 的类，我的使用就是个反例···</p>
<p>声明没什么好说的，思路清晰即可。</p>
<p>绑定的类型参数有一个点，支持多绑定(Multiple Bounds)</p>
<p><code>T extends A &amp; B &amp; C</code></p>
<h2 id="原始类型raw-type">原始类型(Raw Type)</h2>
<p>原始类型在 JDK 5.0 的时候是合法的，但是现在我们使用原始类型编译器均会报 warning，<code>Raw use of parameterized class 'ItemViewBinder' </code></p>
<p>所以原始类型是不建议使用的，但是我们的各种泛型轮子中可能充斥着 warning，虽然运行时 <code>可能</code> 不存在问题，但是其实是不规范的。</p>
<p>因为使用原始类型绕过了编译器的类型检查，而让你的代码变得不再安全。比如下面这段被各种泛型文章用烂了的代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span> <span class="n">names</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span> <span class="c1">// warning: raw type!
</span><span class="c1"></span><span class="n">names</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;John&#34;</span><span class="o">);</span>
<span class="n">names</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;Mary&#34;</span><span class="o">);</span>
<span class="n">names</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Boolean</span><span class="o">.</span><span class="na">FALSE</span><span class="o">);</span> <span class="c1">// not a compilation error!
</span><span class="c1"></span><span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
<span class="o">}</span> <span class="c1">// throws ClassCastException!
</span><span class="c1"></span>  <span class="c1">//    java.lang.Boolean cannot be cast to java.lang.String
</span></code></pre></div><p>上面代码使用了原始类型 List，绕过了编译器的检查，你可以加入任何类型，但是当你取出 List 中的元素时，却完全不知道类型，很容易就会产生 ClassCastException。</p>
<h2 id="泛型的继承和子类型">泛型的继承和子类型</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/img/in-post/generics-subtypeRelationship.gif"
        data-srcset="/img/in-post/generics-subtypeRelationship.gif, /img/in-post/generics-subtypeRelationship.gif 1.5x, /img/in-post/generics-subtypeRelationship.gif 2x"
        data-sizes="auto"
        alt="/img/in-post/generics-subtypeRelationship.gif"
        title="/img/in-post/generics-subtypeRelationship.gif" /></p>
<p>可以看到 <code>Integer extends Number</code>，但是 <code>Box&lt;Integer&gt;</code> 和 <code>Box&lt;Number&gt;</code> 却不是继承关系。</p>
<p>看看下面的代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Integer</span><span class="o">[]</span> <span class="n">integers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">testGenericInheritance</span><span class="o">(</span><span class="n">integerList</span><span class="o">);</span> <span class="c1">// compile error
</span><span class="c1"></span>    <span class="n">testArrayInheritance</span><span class="o">(</span><span class="n">integers</span><span class="o">);</span> <span class="c1">// ok
</span><span class="c1"></span><span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testArrayInheritance</span><span class="o">(</span><span class="n">Number</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testGenericInheritance</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">integerList</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div><p>这也是常说的 java 数组是 <code>协变(covariant)</code> 的，但是这么看泛型就不行了？也不是，<code>通配符(Wildcards)</code> 帮我们完成这件事。</p>
<p>还是上面的代码，改一下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Integer</span><span class="o">[]</span> <span class="n">integers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">testGenericInheritance</span><span class="o">(</span><span class="n">integerList</span><span class="o">);</span> <span class="c1">// ok
</span><span class="c1"></span><span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testGenericInheritance</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">integerList</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div><p>这样就编译通过了。</p>
<p>但是为什么 <code>List&lt;Integer&gt;</code> 却不是 <code>List&lt;Number&gt;</code> 的子类呢？在语义层面和数学逻辑看完全是正确的。</p>
<p>可能是害怕这种语义的出现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">numberList</span> <span class="o">=</span> <span class="n">integerList</span><span class="o">;</span>
    <span class="n">numberList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">0f</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>如果 <code>List&lt;Integer&gt; 是 List&lt;Number&gt;</code> 的子类，那么我们可以使用 <code>List&lt;Number&gt; 接收 List&lt;Integer&gt;</code>，多态的体现。</p>
<p>这个时候，numberList.add(double) 完全正确，但是 List 确是 Integer，互相矛盾。</p>
<h2 id="类型推断type-inference">类型推断(Type Inference)</h2>
<p>看看下面的代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Serializable</span> <span class="n">s</span> <span class="o">=</span> <span class="n">pick</span><span class="o">(</span><span class="s">&#34;d&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;());</span> <span class="c1">// ok
</span><span class="c1"></span>    <span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">pick</span><span class="o">(</span><span class="s">&#34;d&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;());</span> <span class="c1">// compile error
</span><span class="c1"></span>    <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">pick</span><span class="o">(</span><span class="s">&#34;d&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;());</span> <span class="c1">// compile error
</span><span class="c1"></span><span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">pick</span><span class="o">(</span><span class="n">T</span> <span class="n">a1</span><span class="o">,</span> <span class="n">T</span> <span class="n">a2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">a2</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>当使用泛型时，编译器会自动帮我们做类型推导，</p>
<h2 id="通配符wildcards">通配符(Wildcards)</h2>
<p>通配符相关的子类型关系如下图：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/img/in-post/generics-wildcardSubtyping.gif"
        data-srcset="/img/in-post/generics-wildcardSubtyping.gif, /img/in-post/generics-wildcardSubtyping.gif 1.5x, /img/in-post/generics-wildcardSubtyping.gif 2x"
        data-sizes="auto"
        alt="/img/in-post/generics-wildcardSubtyping.gif"
        title="/img/in-post/generics-wildcardSubtyping.gif" /></p>
<p>所以当使用通配符时，是存在继承关系的。</p>
<h3 id="上界通配符upper-bounded-wildcards">上界通配符(Upper Bounded Wildcards)</h3>
<p><code>? extends Type</code> 即为上界通配符</p>
<p>看下面这段代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">numbers2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">numbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="c1">// compile error
</span><span class="c1"></span>    <span class="n">numbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">());</span> <span class="c1">// compile error
</span><span class="c1"></span>    <span class="n">numbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// ok
</span><span class="c1"></span>    <span class="n">numbers2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">numbers2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">));</span> <span class="c1">// compile error
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>一直都有一种思维定式，像代码中的 numbers 应该是存储 Number 以及 Numbers 子类。</p>
<p>但是 add(1) 却编译报错了，add(Object) 也报错了，甚至我创建了和 numbers 一模一样的 numbers2，add(numbers2.get(0)) 也编译报错。</p>
<p>这都是编译器作用的体现，使用了通配符后，<code>List&lt;? extends Number&gt;</code> 在编译器眼中，它的元素类型是 <code>CAP#1</code>，应该是编译器按顺序定的一个值。</p>
<p>所以我们知道了，上界通配符是无法添加任何元素的(null 除外)，所以很多文章也说了它是 <code>只读</code> 类型，如果你想随意改动那么直接使用 <code>List&lt;Number&gt;</code>。</p>
<p>但是又要记住之前的例子，在 Java 中 <code>List&lt;Number&gt; 和 List&lt;Integer&gt; 和 List&lt;Double&gt;</code> 没任何继承关系，所以如果你想写一段通用逻辑，处理 <code>List&lt;Number&gt; 和 List&lt;Integer&gt; 和 List&lt;Double&gt;</code> 中的 Number 元素，还是逃不开使用通配符。</p>
<h3 id="下界通配符lower-bounded-wildcards">下界通配符(Lower Bounded Wildcards)</h3>
<p><code>? super Type</code> 即为下界通配符</p>
<p>看下面这段代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">numbers2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">numbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="c1">// ok
</span><span class="c1"></span>    <span class="n">numbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">BigInteger</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[]{}));</span> <span class="c1">// ok
</span><span class="c1"></span>    <span class="n">numbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">());</span> <span class="c1">// compile error
</span><span class="c1"></span>    <span class="n">numbers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// ok
</span><span class="c1"></span>    <span class="n">numbers2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">numbers2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">));</span> <span class="c1">// compile error
</span><span class="c1"></span>    <span class="n">Number</span> <span class="n">num1</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span> <span class="c1">// compile error
</span><span class="c1"></span>    <span class="n">Object</span> <span class="n">num2</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span> <span class="c1">// ok
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>使用下界通配符可以 add Number 子类元素，但是 get 读取的时候却只能用 Object 类接收。</p>
<h3 id="无界通配符unbounded-wildcards">无界通配符(unBounded Wildcards)</h3>
<p>？ 即为无界通配符</p>
<p><code>List&lt;?&gt;</code> 和 <code>List&lt;Object&gt;</code> 却不相同，<code>List&lt;?&gt;</code> 同样只能添加 null 作为元素</p>
<h3 id="小结">小结</h3>
<p>上界通配符通常代表了只读，而下界通配符表示了可写(当然也可读，但是是 Object)。</p>
<p>这里说一说，<code>协变(covariant)</code> 和 <code>逆变(contravariant)</code></p>
<ul>
<li>𝑓(⋅)是逆变（contravariant）的，当𝐴≤𝐵时有𝑓(𝐵)≤𝑓(𝐴)成立；</li>
<li>𝑓(⋅)是协变（covariant）的，当𝐴≤𝐵时有𝑓(𝐴)≤𝑓(𝐵)成立；</li>
<li>𝑓(⋅)是不变（invariant）的，当𝐴≤𝐵时上述两个式子均不成立，即𝑓(𝐴)与𝑓(𝐵)相互之间没有继承关系。</li>
</ul>
<p>所以通过上面的例子，使用通配符后。</p>
<p>上界通配符实现了协变，下界通配符实现了逆变</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
<span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;();</span>
</code></pre></div><h2 id="类型擦除和桥方法">类型擦除和桥方法</h2>
<p>首先 Java 的泛型是 <code>编译器(compiler)</code> 在 <code>编译时</code> 帮我们做的严格的类型检查实现的，与之对应的就是 <code>类型擦除(Type Erasure)</code> 和 我们经常说的 <code>伪泛型</code>，因为在运行时，我们声明的类型参数都会被擦除掉。</p>
<p>除此之外，编译器就什么也没有做了么？当然不是，编译器也许还会帮我们生成桥方法。</p>
<p>看这段代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="n">data</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Node.setData&#34;</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyNode</span> <span class="kd">extends</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">MyNode</span><span class="o">(</span><span class="n">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="kd">super</span><span class="o">(</span><span class="n">data</span><span class="o">);</span> <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;MyNode.setData&#34;</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">MyNode</span> <span class="n">mn</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyNode</span><span class="o">(</span><span class="n">5</span><span class="o">);</span>
<span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mn</span><span class="o">;</span>            <span class="c1">// A raw type - compiler throws an unchecked warning
</span><span class="c1"></span><span class="n">n</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="s">&#34;Hello&#34;</span><span class="o">);</span>     
<span class="n">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">mn</span><span class="o">.</span><span class="na">data</span><span class="o">;</span>    <span class="c1">// Causes a ClassCastException to be thrown.
</span></code></pre></div><p>这段代码确实有问题，但是是因为 setData 调用了 Node 的 setData(Object data)(类型擦除以后， T 变为 Object) 方法，从而导致 Node.data = String，而 mn 又是 MyNode 类型(<code>extends Node&lt;Integer&gt;</code>)，所以 Integer x = mn.data，编译并没有问题，最终运行时报错，报错在了 mn.data 强转 String 上，报错也让人很困惑，不知道发生了什么。且我们以为是重写了 setData 方法，其实不然，直接调用的父类的 setData 方法。</p>
<p>所以，为了解决这个问题，编译器会帮我们生成桥方法。</p>
<p>通过 javap -v MyNode.class 方式，我们可以看到 MyNode 中居然多了一个 setData(Object) 方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Integer</span><span class="o">);</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Integer</span><span class="o">;)</span><span class="n">V</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PUBLIC</span>
    <span class="n">Code</span><span class="o">:</span>
      <span class="n">stack</span><span class="o">=</span><span class="n">2</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="n">2</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="n">2</span>
         <span class="n">0</span><span class="o">:</span> <span class="n">aload_0</span>
         <span class="n">1</span><span class="o">:</span> <span class="n">aload_1</span>
         <span class="n">2</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="n">2</span>                  <span class="c1">// Method Node.setData:(Ljava/lang/Object;)V
</span><span class="c1"></span>         <span class="n">5</span><span class="o">:</span> <span class="k">return</span>
      <span class="n">LineNumberTable</span><span class="o">:</span>
        <span class="n">line</span> <span class="n">18</span><span class="o">:</span> <span class="n">0</span>
        <span class="n">line</span> <span class="n">19</span><span class="o">:</span> <span class="n">5</span>
      <span class="n">LocalVariableTable</span><span class="o">:</span>
        <span class="n">Start</span>  <span class="n">Length</span>  <span class="n">Slot</span>  <span class="n">Name</span>   <span class="n">Signature</span>
            <span class="n">0</span>       <span class="n">6</span>     <span class="n">0</span>  <span class="k">this</span>   <span class="n">LMyNode</span><span class="o">;</span>
            <span class="n">0</span>       <span class="n">6</span>     <span class="n">1</span>  <span class="n">data</span>   <span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Integer</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span><span class="o">);</span>
    <span class="n">descriptor</span><span class="o">:</span> <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;)</span><span class="n">V</span>
    <span class="n">flags</span><span class="o">:</span> <span class="n">ACC_PUBLIC</span><span class="o">,</span> <span class="n">ACC_BRIDGE</span><span class="o">,</span> <span class="n">ACC_SYNTHETIC</span>
    <span class="n">Code</span><span class="o">:</span>
      <span class="n">stack</span><span class="o">=</span><span class="n">2</span><span class="o">,</span> <span class="n">locals</span><span class="o">=</span><span class="n">2</span><span class="o">,</span> <span class="n">args_size</span><span class="o">=</span><span class="n">2</span>
         <span class="n">0</span><span class="o">:</span> <span class="n">aload_0</span>
         <span class="n">1</span><span class="o">:</span> <span class="n">aload_1</span>
         <span class="n">2</span><span class="o">:</span> <span class="n">checkcast</span>     <span class="err">#</span><span class="n">3</span>                  <span class="c1">// class java/lang/Integer
</span><span class="c1"></span>         <span class="n">5</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="n">4</span>                  <span class="c1">// Method setData:(Ljava/lang/Integer;)V
</span><span class="c1"></span>         <span class="n">8</span><span class="o">:</span> <span class="k">return</span>
      <span class="n">LineNumberTable</span><span class="o">:</span>
        <span class="n">line</span> <span class="n">13</span><span class="o">:</span> <span class="n">0</span>
      <span class="n">LocalVariableTable</span><span class="o">:</span>
        <span class="n">Start</span>  <span class="n">Length</span>  <span class="n">Slot</span>  <span class="n">Name</span>   <span class="n">Signature</span>
            <span class="n">0</span>       <span class="n">9</span>     <span class="n">0</span>  <span class="k">this</span>   <span class="n">LMyNode</span><span class="o">;</span>
</code></pre></div><p>可以看到，编译器帮我们给 MyNode 生成了一个 setData(Object) 方法，从而实现了我们调用 setData(&ldquo;Hello&rdquo;) 时，调用的是具体的子类的 setData(Object) 方法而不是父类的方法。同时，setData 方法内部强转类型 Integer，然后调用了 setData(Integer) 方法。</p>
<p>虽然最终代码还是报错，但是其符合逻辑，报错位置也在 setData 中，调用的也是自己的 setData 而不是父类的 setData。</p>
<p>所以很多时候，编译器有着神奇的作用。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-02-01</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/Java/">Java</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/2021-01-24-Kotlin-Coroutines-VS-Goroutines/" class="prev" rel="prev" title="Kotlin Coroutines VS Goroutines"><i class="fas fa-angle-left fa-fw"></i>Kotlin Coroutines VS Goroutines</a>
            <a href="/posts/2021-02-07-%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%8D%E4%BE%8B/" class="next" rel="next" title="工作中遇到的代码反例">工作中遇到的代码反例<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.87.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/algoliasearch/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"gitalk":{"admin":["PTrain666"],"clientID":"2266a6b1be9e64aca6b8","clientSecret":"95a87d5d16492501b3629046e7d5689bb5f949bf","id":"2021-02-01T00:00:00Z","owner":"PTrain666","repo":"PTrain666.github.io","title":"Java 泛型的见解"}},"data":{"id-1":"北邙山之光的 Blog","id-2":"北邙山之光的 Blog"},"search":{"algoliaAppID":"DY3IPG94HO","algoliaIndex":"blog","algoliaSearchKey":"e9b70bb1815b657ef5122006a8a499b6","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
